<!DOCTYPE html>
<html lang="en">
<head>
  <title>Connection Ϟ Required  // RubyConf 2008 </title>

  <meta charset="utf-8">
  <meta name="author" content="Zach Moazeni">

  <link href="/v2013/css/main.css?v=1" media="screen" rel="stylesheet" type="text/css" />
  <link href="/v2013/css/pygments-github.css" media="screen" rel="stylesheet" type="text/css" />
  <link rel="alternate" type="application/atom+xml" title="Connection Required" href="/v2013/feed/atom/" />
</head>
<body>
  <nav>
    <ul>
      <li><a href="/v2013/">Connection Ϟ Required</a></li>
      <li><a href="/v2013/highlighted">Highlighted</a></li>
      <li><a href="/v2013/about">About</a></li>
    </ul>
  </nav>


  <article id="main">
    <h1><cite>RubyConf 2008</cite></h1>
    <time datetime="2008-11-19T22:11:42-05:00">19 November 2008</time>

    <p>I was lucky enough to attend <a href="http://rubyconf.org/">RubyConf 2008</a>. I really enjoyed last year’s conference, and I felt this year was better.</p>

<p>There was lots of great content, and more than handful of time slots where I wanted to attend both. I’m eagerly waiting for <a href="http://www.confreaks.com/">Confreaks</a> to post all the talks so I could watch the ones I missed, as well as re-watch the ones I attended.</p>

<p>Among all the talks I attended, there were three talks that really enjoyed.</p>

<h3 id="ruby-heavy-lifting-lazy-load-it-event-it-defer-it-and-then-optimize-it">Ruby Heavy-Lifting: Lazy load it, Event it, Defer it, and then Optimize it</h3>

<p>This was given by Ilya Grigorik of <a href="http://aiderss.com/">AideRSS</a>, and was my favorite talk of the weekend. Ilya went over their experiences developing PostRank and main optimization techniques they used with Ruby.</p>

<p>Primarily:</p>

<ol>
  <li>Message Queues</li>
  <li>EventMachine</li>
  <li>Process Forking</li>
  <li>Custom C Extensions</li>
</ol>

<p>Ilya didn’t just gloss over each point in a tutorial fashion, but instead described how they used each item and the resulting effects.</p>

<p>It was very refreshing to hear someone speak of their roadblocks and creative solutions to work around them. Hearing that PostRank is making around 5 million requests per day, and is spread over 100 servers is pretty inspiring.</p>

<h3 id="what-every-rubyist-should-know-about-threads">What Every Rubyist Should Know About Threads</h3>

<p>Jim Weirich from <a href="http://theedgecase.com">EdgeCase</a> gave this talk. Now I’ve been interested in fairly interested in concurrency this year. Especially as we see hardware trends stalling out on speed and moving towards multiple cores. I really appreciated this talk for two reasons.</p>

<p>First, it shamed me. Yup, I’ll admit it. As snobby as I acted about concurrency, and as much as I touted I understood deadlocking and thread safety code, Jim’s talk exposed me to my ignorance, and for that I’m very grateful.</p>

<p>This talk may not appeal to others the same way it did to me, however for those interested in threading basics as well as virtual machine quicks this was worthwhile.</p>

<h3 id="dramatis-actors-for-ruby">Dramatis: Actors for Ruby</h3>

<p><a href="http://smparkes.net/">Steven Parks</a> gave a great talk about his Actor-based Concurrency library for both Ruby and Python <a href="http://dramatis.mischance.net/">Dramatis</a>. Now Dramatis is rather young, but has a lot of potential. Not to mention Steven’s presentation and conversation afterwards indicates he has been working in this particular field a while.</p>

<p>Earlier this year I played with Erlang quite a bit, and despite the syntax annoyances, the actor model was very interesting. Steven mentioned explicit vs implicit receiving, which happens to be one of the bold stances this API takes. Erlang is an explicit receive model. Which means the code has to explicitly request the next message.</p>

<p>An explicit receive example with Ruby:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>while message = receive
  # do something with the message and then re-loop
end
</code></pre>
</div>

<p>An implicit receive example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def some_method
  # this will get called when a message is sent
end
</code></pre>
</div>

<p>The second example doesn’t look too foreign, and that’s because it’s not. The entire class becomes an API, and the messaging framework calls the appropriate method. When I worked with Erlang, I liked the Actor model, but I didn’t like the boilerplate code that was copy-pasted for every Actor.</p>

<p>I don’t expect everyone to prefer this type of messaging, but for me it makes the concurrency model more transparent, and the actors easier to read as well as easier to test.</p>

<h3 id="thats-a-lot-of-concurrency">That’s a lot of concurrency</h3>

<p>As you can tell all my favorite talks all had some connection with concurrency and scale. That’s because I’ve been very interested in scaling Ruby applications. Not because I’m some outside developer who is evaluating Ruby as a language and concerned about FUD. It’s because I am a Ruby developer, and I’ve been writing in Ruby for the past couple years, but I have rarely heard talks addressing scaling.</p>

<p>There were many other great talks at the conference. For those on the fence on whether to attend next year, I definitely recommend it.</p>

  </article>


<footer>
  &copy; 2007-2017 Zach Moazeni
</footer>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1484071-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>

